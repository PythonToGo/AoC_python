# Day 4

## 문제 요약
- 종이 롤(@)들이 그리드에 배치됨
- 지게차는 8방향 인접 위치에 종이 롤이 4개 미만인 경우만 접근 가능
- Part 1: 접근 가능한 롤 개수
- Part 2: 반복 제거로 제거 가능한 총 롤 개수

## 입력 파싱
- 각 줄이 그리드의 한 행
- `@`: 종이 롤
- `.`: 빈 공간
- `read_grid()`: 그리드를 문자열 리스트로 읽기

## Part 1
- **규칙**: 8방향 인접 위치에 종이 롤이 **4개 미만**인 롤만 접근 가능
- **구현**: `solve1()`
  - 그리드의 모든 위치 순회
  - 각 `@` 위치에서 8방향 인접 위치 확인
  - 인접한 `@` 개수 세기 (`count_neighbors()`)
  - 개수가 4 미만이면 카운트 증가

### 구현 세부사항
- **8방향**: `[(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)]`
- **경계 체크**: `0 <= nr < H and 0 <= nc < W`
- **인접 개수**: `grid[nr][nc] == '@'`인 경우 카운트

### 예시
```
..@@.@@@@.
@@@.@.@.@@
```
- 첫 번째 줄의 `@`들 중 일부만 접근 가능 (인접 롤이 4개 미만)
- 총 **13개** 접근 가능

## Part 2
- **규칙**: 접근 가능한 롤을 제거 → 새로운 롤이 접근 가능해질 수 있음 → 반복
- **목표**: 더 이상 제거할 수 없을 때까지 제거한 총 롤 개수

### 구현: `solve2()`
- **알고리즘**: 반복적으로 접근 가능한 롤 찾아서 제거
- **과정**:
  1. 그리드를 리스트로 변환 (가변성 위해)
  2. `while True` 루프:
     - 현재 그리드에서 접근 가능한 모든 롤 찾기 (`to_remove` 리스트)
     - 접근 가능한 롤이 없으면 종료
     - 찾은 롤들을 모두 `.`으로 변경 (제거)
     - 제거한 개수를 `removed_total`에 추가
  3. `removed_total` 반환

### 구현 세부사항
- **가변성**: `grid = [list(row) for row in grid]` (문자열 → 리스트)
- **제거**: `grid[r][c] = '.'`
- **한 번에 제거**: 모든 접근 가능한 롤을 찾은 후 한 번에 제거
  - 제거 순서가 중요하지 않음 (인접 개수는 제거 전 상태 기준)

### 예시
- 초기: 13개 제거 가능 → 제거
- 2차: 12개 제거 가능 → 제거
- 3차: 7개 제거 가능 → 제거
- ... (반복)
- 최종: **43개** 총 제거

## 키포인트
- **Part 1**: 단순 카운팅 - 각 위치에서 인접 개수만 확인
- **Part 2**: 반복 시뮬레이션 - 제거 후 그리드 업데이트하고 다시 확인
- **8방향 탐색**: 상하좌우 + 대각선 4방향
- **경계 처리**: 배열 인덱스 범위 체크 필수
- **가변성**: Part 2에서는 그리드 수정 필요 → 리스트로 변환
- **한 번에 제거**: 같은 라운드의 제거는 동시에 처리 (순서 무관)

