# Day 2

## 문제 요약
- 제품 ID 범위들에서 무효 ID 찾기
- 무효 ID: 특정 패턴을 만족하는 ID
- 모든 무효 ID의 합 구하기

## 입력 파싱
- 한 줄 입력: `11-22,95-115,998-1012,...`
- 쉼표(`,`)로 범위 구분
- 각 범위: `시작-끝` 형식
- `parse_ranges()`: `(start, end)` 튜플 리스트 반환

## Part 1
- **규칙**: 같은 숫자 시퀀스가 **정확히 2번** 반복
- **구현**: `is_invalid_id()`
  - 문자열로 변환
  - 길이가 짝수인지 확인 (`len(s) % 2 != 0`이면 False)
  - 앞 절반과 뒤 절반이 같은지 확인
  - `s[:half] == s[half:]`

### 예시
- `55`: 길이 2, `5` == `5` -> 무효
- `6464`: 길이 4, `64` == `64` -> 무효
- `123123`: 길이 6, `123` == `123` -> 무효
- `123`: 길이 3 (홀수) -> 유효

## Part 2
- **규칙**: 같은 숫자 시퀀스가 **최소 2번 이상** 반복
- **구현**: `is_invalid_id_p2()`
  - 문자열로 변환
  - 길이 < 2면 False
  - 블록 길이 `k`를 1부터 `length//2`까지 시도
  - `length % k == 0`인 경우만 확인 (나누어떨어져야 반복 가능)
  - 첫 `k`개 문자를 블록으로 사용
  - 블록을 `(length // k)`번 반복했을 때 원래 문자열과 같은지 확인
  - `block * (length // k) == s`

### 예시
- `12341234`: k=4, `1234` * 2 = `12341234` -> 무효
- `123123123`: k=3, `123` * 3 = `123123123` -> 무효
- `1212121212`: k=2, `12` * 5 = `1212121212` -> 무효
- `1111111`: k=1, `1` * 7 = `1111111` -> 무효

## 키포인트
- Part 1: 정확히 2번 반복 -> 길이 짝수 + 앞뒤 절반 비교
- Part 2: 최소 2번 이상 반복 -> 가능한 모든 블록 길이 시도
- 범위 처리: `range(start, end + 1)` (끝 포함)
- 문자열 슬라이싱과 반복 연산 활용

