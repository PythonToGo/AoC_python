# Day 3

## 문제 요약
- 배터리 뱅크들에서 최대 전압 만들기
- 각 뱅크는 숫자 문자열
- 배터리 순서 재배치 불가
- 각 뱅크의 최대값 합 구하기

## Part 1
- **규칙**: 각 뱅크에서 **정확히 2개** 배터리 선택
- **목표**: 2자리 숫자 최대화

### 구현: `max_joltage_for_bank()`
- **알고리즘**: 첫 번째 자리 선택 + 그 뒤 최대값 선택
- **suffix_max 배열**: `suffix_max[i]` = i번째부터 끝까지의 최대값
  - 역순으로 계산: `suffix_max[i] = max(digits[i], suffix_max[i+1])`
- **최대값 찾기**:
  - 첫 번째 자리 `i`를 0부터 n-2까지 시도
  - `cand = 10 * digits[i] + suffix_max[i+1]`
  - 모든 후보 중 최대값 반환

### 예시
- `987654321111111`:
  - 첫 자리 9 선택 -> 뒤 최대값 8 -> **98**
- `811111111111119`:
  - 첫 자리 8 선택 -> 뒤 최대값 9 -> **89**

## Part 2
- **규칙**: 각 뱅크에서 **정확히 12개** 배터리 선택
- **목표**: 12자리 숫자 최대화

### 구현: `max_joltage_for_bank_p2()`
- **알고리즘**: 스택을 사용한 그리디
- **핵심**: 작은 숫자를 앞에서 제거해서 큰 숫자를 앞으로 이동
- **과정**:
  1. `drops = n - k` (제거할 개수)
  2. 각 숫자를 순회:
     - 스택이 있고, `drops > 0`이고, `stack[-1] < 현재숫자`면
     - 스택에서 제거 (작은 숫자 제거)
     - `drops` 감소
     - 현재 숫자를 스택에 추가
  3. 스택의 앞 `k`개를 사용

### 예시
- `987654321111111` (15자리, 3개 제거):
  - 작은 숫자들(끝의 1들) 제거 -> **987654321111**
- `234234234234278` (15자리, 3개 제거):
  - 앞의 작은 숫자들(2, 3, 2) 제거 -> **434234234278**

## 키포인트
- **Part 1**: 첫 자리 선택 + suffix 최대값 활용
- **Part 2**: 스택 그리디 - 작은 숫자를 앞에서 제거
- 순서 유지 중요 (재배치 불가)
- 각 뱅크 독립적으로 처리 후 합산

