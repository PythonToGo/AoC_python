# Day 5

## 문제 요약
- 재료 ID 범위와 사용 가능한 재료 ID 목록이 주어짐
- 범위는 inclusive (시작과 끝 포함)
- 범위들은 겹칠 수 있음
- Part 1: 사용 가능한 ID 중 신선한 재료 개수
- Part 2: 모든 범위를 합쳤을 때 신선한 재료 ID의 총 개수

## 입력 파싱
- 빈 줄로 구분된 두 섹션
- 첫 번째 섹션: 신선한 재료 ID 범위 (형식: `start-end`)
- 두 번째 섹션: 사용 가능한 재료 ID 목록 (한 줄에 하나씩)
- `blank_line_idx`: 빈 줄의 인덱스 찾기

## Part 1
- **규칙**: 사용 가능한 ID 중 하나 이상의 범위에 포함되는 ID 개수
- **구현**: `solve1()`
  - 범위와 사용 가능한 ID 파싱
  - 각 사용 가능한 ID에 대해 모든 범위 확인
  - 하나의 범위라도 포함되면 신선한 것으로 카운트

### 구현 세부사항
- **범위 파싱**: `start, end = map(int, line.split('-'))`
- **범위 체크**: `start <= ingredient_id <= end`
- **조기 종료**: 하나의 범위에 포함되면 즉시 `break`

### 예시
```
범위: 3-5, 10-14, 16-20, 12-18
사용 가능: 1, 5, 8, 11, 17, 32
```
- 1: 범위 없음 → spoiled
- 5: 3-5에 포함 → fresh
- 8: 범위 없음 → spoiled
- 11: 10-14에 포함 → fresh
- 17: 16-20, 12-18에 포함 → fresh
- 32: 범위 없음 → spoiled
- **결과: 3개**

### 실제 결과
- **558개** 신선한 재료

## Part 2
- **규칙**: 모든 범위를 합쳤을 때 고유한 신선한 재료 ID의 총 개수
- **목표**: 범위들이 겹치거나 인접한 경우 병합하여 총 개수 계산

### 구현: `solve2()`
- **알고리즘**: 범위 병합 (Interval Merging)
- **과정**:
  1. 범위를 시작값으로 정렬
  2. 겹치거나 인접한 범위들을 병합
  3. 병합된 범위들의 길이 합산

### 구현 세부사항
- **정렬**: `ranges.sort()` - 시작값 기준
- **병합 조건**: `start <= last_end + 1`
  - 겹치는 경우: `start <= last_end`
  - 인접한 경우: `start == last_end + 1`
- **병합**: `merged[-1] = (last_start, max(last_end, end))`
- **길이 계산**: `end - start + 1` (inclusive)

### 예시
```
범위: 3-5, 10-14, 16-20, 12-18
정렬: 3-5, 10-14, 12-18, 16-20
병합:
  - 3-5: 독립
  - 10-14와 12-18: 겹침 → 10-18
  - 10-18과 16-20: 겹침 → 10-20
최종: 3-5, 10-20
총 개수: (5-3+1) + (20-10+1) = 3 + 11 = 14
```

### 실제 결과
- **344813017450467개** 신선한 재료 ID

## 키포인트
- **Part 1**: 단순 범위 체크 - 각 ID가 범위에 포함되는지 확인
- **Part 2**: 범위 병합 알고리즘 필수
  - 범위가 매우 크기 때문에 (수조 단위) 모든 숫자를 하나씩 추가하면 메모리/시간 초과
  - 병합 알고리즘으로 O(n log n) 시간 복잡도로 효율적 계산
- **Inclusive 범위**: 시작과 끝 모두 포함 (`end - start + 1`)
- **인접 범위 병합**: `start == last_end + 1`인 경우도 병합 (연속된 범위)
- **정렬 필수**: 병합 전 시작값 기준 정렬 필요

